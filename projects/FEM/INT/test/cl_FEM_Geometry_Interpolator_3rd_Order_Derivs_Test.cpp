/*
 * Copyright (c) 2022 University of Colorado
 * Licensed under the MIT license. See LICENSE.txt file in the MORIS root for details.
 *
 *------------------------------------------------------------------------------------
 *
 * cl_FEM_Geometry_Interpolator_3rd_Order_Derivs_Test.cpp
 *
 */

#include "catch.hpp"
#include "cl_FEM_Geometry_Interpolator.hpp" //FEM/INT/sr

using namespace moris;
using namespace fem;

TEST_CASE( "Geometry_Interpolator_Derivatives", "[moris],[fem],[GeoInterpolator_Derivatives]" )
{
    // define an epsilon environment
    double tEpsilon = 1E-12;

    SECTION( "Geometry Interpolator : 2D space - 3rd derivatives" )
    {
        // space and time geometry interpolator
        //------------------------------------------------------------------------------
        // create a distorted QUAD9 space element
        Matrix< DDRMat > tXHat( 9, 2 );

        tXHat( 0, 0 ) =  1.0;   tXHat( 0, 1 ) =  1.0;
        tXHat( 1, 0 ) = 11.0;   tXHat( 1, 1 ) =  2.0;
        tXHat( 2, 0 ) = 11.0;   tXHat( 2, 1 ) = 10.0;
        tXHat( 3, 0 ) =  1.0;   tXHat( 3, 1 ) =  9.0;
        tXHat( 4, 0 ) =  5.0;   tXHat( 4, 1 ) =  0.0;
        tXHat( 5, 0 ) = 12.0;   tXHat( 5, 1 ) =  7.0;
        tXHat( 6, 0 ) =  6.0;   tXHat( 6, 1 ) = 10.0;
        tXHat( 7, 0 ) =  0.0;   tXHat( 7, 1 ) =  5.0;
        tXHat( 8, 0 ) =  6.0;   tXHat( 8, 1 ) =  6.0;

        //create a line time element
        Matrix< DDRMat > tTHat( 2, 1 );
        tTHat( 0 ) = 0.0;
        tTHat( 1 ) = 1.0;

        // create a space and time geometry interpolation rule
        mtk::Interpolation_Rule tGeomInterpRule(
                mtk::Geometry_Type::QUAD,
                mtk::Interpolation_Type::LAGRANGE,
                mtk::Interpolation_Order::QUADRATIC,
                mtk::Interpolation_Type::LAGRANGE,
                mtk::Interpolation_Order::LINEAR );

        // create a space and time geometry interpolator
        Geometry_Interpolator tGeomInterpolator( tGeomInterpRule );

        //set nodal points xHat, tHat
        tGeomInterpolator.set_coeff( tXHat, tTHat );

        // set random test point in element: xi = (0.2, -0.6)
        Matrix< DDRMat > tXi(2,1);
        tXi( 0, 0 ) =   0.2;
        tXi( 1, 0 ) = - 0.6;

        tGeomInterpolator.set_space( tXi );

        // set nominal values --------------------------------------------------------------

        // first help matrix
        Matrix< DDRMat > tJ3a_nominal = {
                { 198.359290368,   1.450571968, 115.505512704,  22.419794304 },
                {   2.176782336, 244.844425216,  31.523033088, 152.166739968 },
                {  44.079842304,   8.016588544, 229.892401152,  84.262747392 },
                {   9.795520512,  44.303690752,  96.470424576, 246.606114816 }
        };

        // second help matrix
        Matrix< DDRMat > tJ3b_nominal = {
                {  16.79616,   5.29776,  30.55392 },
                { - 5.28768, -40.53888, -33.92256 },
                {  10.10880,   9.66880,   9.28160 },
                { - 5.96160, - 2.94560, - 4.73120 }
        };

        // third help matrix
        Matrix< DDRMat > tJ3c_nominal = {
                {   0.0,   0.0 },
                {   0.0,   0.0 },
                { - 2.2, - 3.2 },
                { - 1.6, - 0.6 }
        };

        // ---------------------------------------------------------------------------------

        // construct jacobian matrices

        Matrix< DDRMat > tdNdXi   = tGeomInterpolator.dNdXi();
        Matrix< DDRMat > td2NdXi2 = tGeomInterpolator.d2NdXi2();
        Matrix< DDRMat > td3NdXi3 = tGeomInterpolator.d3NdXi3();

        Matrix< DDRMat > tJ3a;
        Matrix< DDRMat > tJ3b;
        Matrix< DDRMat > tJ3c;
        Matrix< DDRMat > tJ = tGeomInterpolator.space_jacobian();
        Matrix< DDRMat > tJ2b;
        tGeomInterpolator.second_space_jacobian( tJ2b );

        tGeomInterpolator.space_jacobian_and_matrices_for_third_derivatives(tJ,
                tJ2b,
                tJ3a, tJ3b, tJ3c,
                tdNdXi, td2NdXi2, td3NdXi3 );

        // check if all entries in the matrices are equal to the expected values
        bool tJ3aCheck = true;
        for ( uint i = 0; i < 4; i++)
        {
            for ( uint j = 0; j < 4; j++)
            {
                tJ3aCheck = tJ3aCheck && ( std::abs( tJ3a_nominal( i, j ) - tJ3a( i, j ) ) < tEpsilon );
            }
        }
        REQUIRE( tJ3aCheck );

        bool tJ3bCheck = true;
        for ( uint i = 0; i < 4; i++)
        {
            for ( uint j = 0; j < 3; j++)
            {
                tJ3bCheck = tJ3bCheck && ( std::abs( tJ3b_nominal( i, j ) - tJ3b( i, j ) ) < tEpsilon );
            }
        }
        REQUIRE( tJ3bCheck );

        bool tJ3cCheck = true;
        for ( uint i = 0; i < 4; i++)
        {
            for ( uint j = 0; j < 2; j++)
            {
                tJ3cCheck = tJ3cCheck && ( std::abs( tJ3c_nominal( i, j ) - tJ3c( i, j ) ) < tEpsilon );
            }
        }
        REQUIRE( tJ3cCheck );
    }

    //___________________________________________________________________________________________________________
    SECTION( "Geometry Interpolator : 3D space - 3rd derivatives" )
    {
        // space and time geometry interpolator
        //------------------------------------------------------------------------------
        // create a distorted HEX27 space element
        Matrix< DDRMat > tXHat = {
                { 1.0,  1.0,  4.0},
                {11.0,  2.0,  4.0},
                {11.0, 10.0,  4.0},
                { 1.0,  9.0,  4.0},
                { 1.0,  2.0,  0.0},
                {11.0,  1.0,  0.0},
                {11.0,  9.0,  0.0},
                { 1.0, 10.0,  0.0},
                { 5.0,  0.0,  5.0},
                {12.0,  7.0,  6.0},
                { 6.0, 10.0,  5.0},
                { 0.0,  5.0,  6.0},
                { 1.0,  2.0,  2.0},
                {11.0,  1.0,  2.0},
                {12.0,  9.0,  2.0},
                { 2.0, 10.0,  2.0},
                { 5.0,  0.0, -1.0},
                {12.0,  7.0, -1.0},
                { 6.0, 10.0, -1.0},
                { 0.0,  5.0, -1.0},
                { 6.0,  6.0,  3.0},
                { 6.0,  6.0,  7.0},
                { 6.0,  6.0, -2.0},
                { 0.0,  6.0,  2.0},
                {12.0,  6.0,  2.0},
                { 6.0,  0.0,  2.0},
                { 5.0, 10.0,  2.0}
        };

        //create a line time element
        Matrix< DDRMat > tTHat( 2, 1 );
        tTHat( 0 ) = 0.0;
        tTHat( 1 ) = 1.0;

        // create a space and time geometry interpolation rule
        mtk::Interpolation_Rule tGeomInterpRule( mtk::Geometry_Type::HEX,
                mtk::Interpolation_Type::LAGRANGE,
                mtk::Interpolation_Order::QUADRATIC,
                mtk::Interpolation_Type::LAGRANGE,
                mtk::Interpolation_Order::LINEAR );

        // create a space and time geometry interpolator
        Geometry_Interpolator tGeomInterpolator( tGeomInterpRule );

        //set nodal points xHat, tHat
        tGeomInterpolator.set_coeff( tXHat, tTHat );

        // set random test point in element: xi = (0.2, -0.6, 0.3)
        Matrix< DDRMat > tXi(3,1);
        tXi( 0, 0 ) =   0.2;
        tXi( 1, 0 ) = - 0.6;
        tXi( 2, 0 ) =   0.3;

        tGeomInterpolator.set_space( tXi );

        // set nominal values --------------------------------------------------------------

        // first help matrix
        Matrix< DDRMat > tJ3a_nominal = {
                {172.80124713094300,   0.00349796383200,  -0.00144136526234,  14.12833361043460,  -10.51341610431280,   0.38504701002240,   -0.00780889317120,   0.21321589594522,   0.00581088651264,   -0.57305547104256},
                {  0.07343372746938, 250.38054419795200,   0.17780771091917,   3.31577584411584,    0.29582520033370,  49.90608460763520,   67.01497157456640,   0.39724048775347,   5.97890759913216,    8.90499127262976},
                { -0.04025486249165,   0.00024297062400, -68.75169402414690,   0.02198795010048,   -1.44353711377613,  -0.00400340828160,   -0.04785399889920, -17.25505334319510,   3.14167637901312,    0.52565777252352},
                { 12.99161392776810,   0.14523693307200,   0.00717518160691, 196.24625746965500,   16.91847133677160,  10.66785905037600,   -0.20319468312000,  -0.70225556794163,   0.06113891501056,   -6.99463078116864},
                {-10.63254829812940,   0.00143789817600,  -0.05227296908902,   1.35634913206272, -126.66293155646700,   0.09762275001600,   -0.09653984524800,   5.15065976694375,   0.14128908115968,   -6.99429973635072},
                {  0.97674082363699,   6.03029869411200,  -0.03571837925990,  29.42867362276320,    2.60336881755699, 222.06798510207400,   -3.41135227982080,   1.70803077999206,  -0.75270378268800,   38.95692157907840},
                { -0.06009935781427,   2.47885796121600,  -1.29537306313114,  -1.79818082020608,   -0.87979197409587, -13.28525845463040, -162.29788820295700,  -2.03769936427622, -29.01881399104510,  -24.02496221545470},
                {  0.65422608452813,   0.00059107276800,  -1.89574660135322,  -0.22040361584640,   15.62707255069900,   0.01519522467840,   -0.07804920913920,  93.15976386222490,   2.60532932567040,   -2.41659503861760},
                {  0.04918629264998,   0.02454159052800,   9.43711250772787,   0.72239699460096,    1.24192688526950,  -0.26794938193920,   -3.22018422435840,   8.60681773034701, 105.48899230941200,   17.46012144451580},
                { -0.79938058810982,   0.05970213849600,   0.26021720943821, -11.90780023368960,  -10.61246154501730,   1.86668424103680,   -3.95862203005440, -12.61544026574030,   2.56300784215040, -143.67019439769600}
        };

        // second help matrix
        Matrix< DDRMat > tJ3b_nominal = {
                {-5.855099904,   0.710424000,  0.191399424,  -0.785862720,  -9.318928896,  25.907653440},
                {-1.662812208, -42.316999200, -1.581018912, -21.496368960,  -3.410245872, -27.838712880},
                { 1.174569984,   0.061401600,  7.236304896,  -4.141317120,  14.645385216,  -0.551093760},
                {11.968956480,   9.891266400, -0.218916480,  -2.859043200,  -5.545145280,   0.936088800},
                { 2.045053440,   0.192067200,  2.188712960,  -6.328416000,   7.757007360,   2.971584000},
                {-6.461459360,   2.105758000, -0.385376640,  -5.177408400,  -4.213285440,   1.205926000},
                { 0.938045760,   2.280624000,  1.442538240, -17.539324800,   4.609079040,   8.136297600},
                {-6.481520640,   0.088728000, -4.469288960,  -2.613644800,  -4.945781760,   1.461225600},
                {-0.874849920,   2.091280000, 17.130424320,  -5.365731200,  -4.167143680,  -7.122385600},
                { 2.921261184,   2.007724800,  2.341453056,   2.497464960, -15.912760704,   2.378381280},

        };

        // third help matrix
        Matrix< DDRMat > tJ3c_nominal = {
                { 0.000,  0.000,  0.000},
                { 0.000,  0.000,  0.000},
                { 0.000,  0.000,  0.000},
                {-0.562, -3.200, -2.184},
                { 0.864,  0.000,  2.768},
                {-1.236, -0.990,  0.728},
                {-0.024, -0.320,  3.552},
                { 0.576,  1.640,  0.512},
                { 1.928,  0.240, -1.104},
                {-0.216,  0.960,  0.288},
        };

        // third shape function derivatives
        Matrix< DDRMat > td3NdXi3_nominal = {
                { 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.000},
                { 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.000},
                { 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.000},
                { 0.1155,  0.1155,  0.0105,  0.0105, -0.2145, -0.2145, -0.0195, -0.0195, -0.2310, -0.1260, -0.0210, -0.1260, -1.0010, -1.0010, -0.0910, -0.0910,  0.4290,  0.2340,  0.0390,  0.2340, -2.1840,  0.2520, -0.4680,  1.0920,  1.0920,  2.0020,  0.182},
                {-0.0960, -0.0960,  0.0240,  0.0240,  0.3840,  0.3840, -0.0960, -0.0960,  0.1920, -0.1280, -0.0480, -0.1280, -0.2880, -0.2880,  0.0720,  0.0720, -0.7680,  0.5120,  0.1920,  0.5120,  0.7680,  0.2560, -1.0240, -0.3840, -0.3840,  0.5760, -0.144},
                { 0.0315, -0.0735, -0.0735,  0.0315, -0.0585,  0.1365,  0.1365, -0.0585,  0.0420,  0.1470,  0.0420, -0.0630, -0.2730,  0.6370,  0.6370, -0.2730, -0.0780, -0.2730, -0.0780,  0.1170,  0.7280, -0.0840,  0.1560,  0.5460, -1.2740, -0.3640, -0.364},
                { 0.0160, -0.0240, -0.0240,  0.0160, -0.0640,  0.0960,  0.0960, -0.0640, -0.1920,  0.0480, -0.1920, -0.0320,  0.0480, -0.0720, -0.0720,  0.0480,  0.7680, -0.1920,  0.7680,  0.1280,  1.1520,  0.3840, -1.5360, -0.0960,  0.1440, -0.5760, -0.576},
                {-0.1440,  0.3360, -0.0840,  0.0360, -0.1440,  0.3360, -0.0840,  0.0360, -0.1920,  0.4480,  0.0480, -0.1920,  0.2880, -0.6720,  0.1680, -0.0720, -0.1920,  0.4480,  0.0480, -0.1920,  0.5120, -0.2560, -0.2560,  0.3840, -0.8960,  0.3840, -0.096},
                { 0.0880, -0.1320, -0.0120,  0.0080,  0.0880, -0.1320, -0.0120,  0.0080, -1.0560,  0.1440, -0.0960, -0.0960, -0.1760,  0.2640,  0.0240, -0.0160, -1.0560,  0.1440, -0.0960, -0.0960, -2.3040,  1.1520,  1.1520,  0.1920, -0.2880,  2.1120,  0.192},
                {-0.0660,  0.1540,  0.0140, -0.0060,  0.2640, -0.6160, -0.0560,  0.0240, -0.0880, -0.1680, -0.0080,  0.0720, -0.1980,  0.4620,  0.0420, -0.0180,  0.3520,  0.6720,  0.0320, -0.2880,  0.2880,  0.0960, -0.3840,  0.2160, -0.5040, -0.2640, -0.024}
        };

        // ---------------------------------------------------------------------------------

        // construct jacobian matrices

        Matrix< DDRMat > tdNdXi   = tGeomInterpolator.dNdXi();
        Matrix< DDRMat > td2NdXi2 = tGeomInterpolator.d2NdXi2();
        Matrix< DDRMat > td3NdXi3 = tGeomInterpolator.d3NdXi3();

        Matrix< DDRMat > tJ3a;
        Matrix< DDRMat > tJ3b;
        Matrix< DDRMat > tJ3c;
        Matrix< DDRMat > tJ = tGeomInterpolator.space_jacobian();
        Matrix< DDRMat > tJ2b;
        tGeomInterpolator.second_space_jacobian( tJ2b );

        tGeomInterpolator.space_jacobian_and_matrices_for_third_derivatives(tJ,
                tJ2b,
                tJ3a, tJ3b, tJ3c,
                tdNdXi, td2NdXi2, td3NdXi3 );

        // for debugging
        //        Matrix< DDRMat > t_Delta_d3NdXi3 = td3NdXi3_nominal - td3NdXi3;
        //        print( t_Delta_d3NdXi3 , "delta_d3NdXi3" );
        //        Matrix< DDRMat > t_Delta_J3a = tJ3a_nominal - tJ3a;
        //        print( t_Delta_J3a , "delta_J3a" );
        //        Matrix< DDRMat > t_Delta_J3b = tJ3b_nominal - tJ3b;
        //        print( t_Delta_J3b , "delta_J3b" );
        //        Matrix< DDRMat > t_Delta_J3c = tJ3c_nominal - tJ3c;
        //        print( t_Delta_J3c , "delta_J3c" );

        // check if all entries in the matrices are equal to the expected values
        bool tJ3aCheck = true;
        for ( uint i = 0; i < 10; i++)
        {
            for ( uint j = 0; j < 10; j++)
            {
                tJ3aCheck = tJ3aCheck && ( std::abs( tJ3a_nominal( i, j ) - tJ3a( i, j ) ) < tEpsilon );
            }
        }
        REQUIRE( tJ3aCheck );

        bool tJ3bCheck = true;
        for ( uint i = 0; i < 10; i++)
        {
            for ( uint j = 0; j < 6; j++)
            {
                tJ3bCheck = tJ3bCheck && ( std::abs( tJ3b_nominal( i, j ) - tJ3b( i, j ) ) < tEpsilon );
            }
        }
        REQUIRE( tJ3bCheck );

        bool tJ3cCheck = true;
        for ( uint i = 0; i < 10; i++)
        {
            for ( uint j = 0; j < 3; j++)
            {
                tJ3cCheck = tJ3cCheck && ( std::abs( tJ3c_nominal( i, j ) - tJ3c( i, j ) ) < tEpsilon );
            }
        }
        REQUIRE( tJ3cCheck );

        bool td3NdXi3Check = true;
        for ( uint i = 0; i < 10; i++)
        {
            for ( uint j = 0; j < 27; j++)
            {
                td3NdXi3Check = td3NdXi3Check && ( std::abs( td3NdXi3_nominal( i, j ) - td3NdXi3( i, j ) ) < tEpsilon );
            }
        }
        REQUIRE( td3NdXi3Check );

    }

    //------------------------------------------------------------------------------
}

//------------------------------------------------------------------------------

TEST_CASE( "GI_3rd_Derivatives_Analytic", "[moris],[fem],[GI_3rd_Derivatives_Analytic]" )
{
    // define an epsilon environment
    double tEpsilon = 1E-12;

    //------------------------------------------------------------------------------

    SECTION( "Geometry Interpolator : 2D space - 3rd analytic derivatives" )
    {
        // number of spatial dimensions
        uint tNumDims = 2;

        // create a distorted HEX64 space element
        Matrix< DDRMat > tXHat = {
                { +1.347723862327497e-01, -1.461655891898730e-01 }, 
                { +4.368601255586528e-01, -1.755849727220097e+00 }, 
                { +4.916045200549456e+00, +5.093735163500106e+00 }, 
                { +1.516611619471673e+00, +4.240276316407341e-01 }, 
                { +1.036044210173250e-01, -4.734154845638269e-01 }, 
                { +1.361446881121298e-01, -7.578265393242966e-01 }, 
                { +1.145659977003276e+00, +4.969589558898699e-02 }, 
                { +1.966515903842097e+00, +1.786590628055923e+00 }, 
                { +1.532054315367079e+00, +2.198461309841859e+00 }, 
                { +1.165874354054645e+00, +1.373382393313394e+00 }, 
                { +6.066748266084740e-01, +1.487246133553463e-01 }, 
                { +3.534388237302248e-01, +4.136931393658021e-03 }, 
                { +2.717012417838766e-01, +1.339910023413098e-02 }, 
                { +3.570376674964340e-01, +2.144879939836832e-02 }, 
                { +6.128522122584514e-01, +7.710943435873692e-01 }, 
                { +4.663729411751219e-01, +4.817039036919046e-01 } }; 

        // get parametric nodal points of a HEX64 element
        Matrix< DDRMat > tParamNodalPoints = { 
                { -1.000000000000000e+00, -1.000000000000000e+00 }, 
                { +1.000000000000000e+00, -1.000000000000000e+00 }, 
                { +1.000000000000000e+00, +1.000000000000000e+00 }, 
                { -1.000000000000000e+00, +1.000000000000000e+00 }, 
                { -3.333333333333333e-01, -1.000000000000000e+00 }, 
                { +3.333333333333333e-01, -1.000000000000000e+00 }, 
                { +1.000000000000000e+00, -3.333333333333333e-01 }, 
                { +1.000000000000000e+00, +3.333333333333333e-01 }, 
                { +3.333333333333333e-01, +1.000000000000000e+00 }, 
                { -3.333333333333333e-01, +1.000000000000000e+00 }, 
                { -1.000000000000000e+00, +3.333333333333333e-01 }, 
                { -1.000000000000000e+00, -3.333333333333333e-01 }, 
                { -3.333333333333333e-01, -3.333333333333333e-01 }, 
                { +3.333333333333333e-01, -3.333333333333333e-01 }, 
                { +3.333333333333333e-01, +3.333333333333333e-01 }, 
                { -3.333333333333333e-01, +3.333333333333333e-01 } }; 

        // create a space and time geometry interpolation rule
        mtk::Interpolation_Rule tGeomInterpRule( mtk::Geometry_Type::QUAD,
                mtk::Interpolation_Type::LAGRANGE,
                mtk::Interpolation_Order::CUBIC,
                mtk::Interpolation_Type::CONSTANT,
                mtk::Interpolation_Order::CONSTANT );

        // create a space and time geometry interpolator
        Geometry_Interpolator tGeomInterpolator( tGeomInterpRule );

        //set nodal points xHat, tHat
        tGeomInterpolator.set_space_coeff( tXHat );

        // test that the nodal points used to generate the unit test are indeed the nodal points in the order used by moris
        for( uint iNode = 0; iNode < tXHat.n_rows(); iNode++ )
        {
            // set space interpolator to each parametric nodal point
            Matrix< DDRMat > tXi = tParamNodalPoints( { iNode, iNode }, { 0, tNumDims - 1 } );
            tGeomInterpolator.set_space( trans( tXi ) );

            // check that the space interpolation puts it on top of the physical nodal points provided
            Matrix< DDRMat > tXNodeNominal = tXHat( { iNode, iNode }, { 0, tNumDims - 1 } ); 
            Matrix< DDRMat > tXNode = tGeomInterpolator.valx();
            if( norm( tXNode - tXNodeNominal ) > tEpsilon )
            {
                std::cout << "Incorrect spatial position of nodal point #" << iNode << '\n';
                moris::print_as_row_vector( tXNodeNominal, "tXNodeNominal" );
                moris::print_as_row_vector( tXNode, "tXNode" );
            }
            REQUIRE( norm( tXNode - tXNodeNominal ) < tEpsilon );
        }

        // set random test point in parent element
        Matrix< DDRMat > tXi = {
                { +9.083489127590862e-01 }, 
                { -9.361547409920432e-01 } }; 
        tGeomInterpolator.set_space( tXi );

        // the known physical position of this point
        Matrix< DDRMat > tXNominal = { 
                { +4.729834443374148e-01 }, 
                { -1.353654457813573e+00 } }; 
        tXNominal = trans( tXNominal );      

        // get the interpolated physical point position
        Matrix< DDRMat > tX = tGeomInterpolator.valx();

        // check that the interpolated physical point position is correct
        if( norm( tX - tXNominal ) > tEpsilon )
        {
            std::cout << "Incorrect spatial point: " << '\n';
            moris::print_as_row_vector( tXNominal, "tXNominal" );
            moris::print_as_row_vector( tX, "tX" );
        }
        REQUIRE( norm( tX - tXNominal ) < tEpsilon );

        // first help matrix
        Matrix< DDRMat > tJ3aNominal = {
                { +5.901460568095724e-01, -6.347473246089026e+00, -3.908059982487286e+00, +8.626640049801985e+00 }, 
                { +3.186877830453145e+00, +2.567708253227907e+01, +1.916667404189363e+01, +3.842437785740949e+01 }, 
                { +1.035368174681731e+00, +1.011383377867442e+01, -2.495283590883512e+00, -4.118646962551426e+00 }, 
                { +1.816477878271560e+00, -1.611501612325520e+01, +3.273477894570059e+00, -8.776377589590840e+00 } }; 

        // second help matrix
        Matrix< DDRMat > tJ3bNominal = {
                { +3.199301304844616e+00, +1.492481038419729e+01, -1.382339958967757e+01 }, 
                { -1.447976252293272e+01, -2.723159210185118e+01, -4.261183427826637e+01 }, 
                { +6.249011548661854e+00, -2.286989059502172e+01, -3.097744757167159e+00 }, 
                { +4.929845870055978e+00, +2.950652215307195e+01, +3.076690875253328e+01 } }; 

        // third help matrix
        Matrix< DDRMat > tJ3cNominal = {
                { +8.771853594889597e-01, -2.231790485420882e+00 }, 
                { +5.797039956587028e+00, +4.878070033836942e+00 }, 
                { +3.955699119670338e+00, +5.855913896528117e+00 }, 
                { -5.816462643282599e+00, -4.208516440025092e+00 } }; 

        // get the derivatives of the shape functions
        Matrix< DDRMat > tdNdXi   = tGeomInterpolator.dNdXi();
        Matrix< DDRMat > td2NdXi2 = tGeomInterpolator.d2NdXi2();
        Matrix< DDRMat > td3NdXi3 = tGeomInterpolator.d3NdXi3();

        // get the first and second order Jacobians
        Matrix< DDRMat > tJ = tGeomInterpolator.space_jacobian();
        Matrix< DDRMat > tJ2b;
        tGeomInterpolator.second_space_jacobian( tJ2b );

        // get the third order Jacobians
        Matrix< DDRMat > tJ3a;
        Matrix< DDRMat > tJ3b;
        Matrix< DDRMat > tJ3c;
        tGeomInterpolator.space_jacobian_and_matrices_for_third_derivatives( tJ, tJ2b, tJ3a, tJ3b, tJ3c, tdNdXi, td2NdXi2, td3NdXi3 );

        // check the first helper matrix
        bool tJ3aCheck = true;
        for ( uint i = 0; i < 4; i++)
        {
            for ( uint j = 0; j < 4; j++)
            {
                bool tCheckEntry = ( std::abs( tJ3aNominal( i, j ) - tJ3a( i, j ) ) < tEpsilon );
                tJ3aCheck = tJ3aCheck && tCheckEntry;

                // print what entries are wrong
                if( !tCheckEntry )
                {
                    std::cout << "2D: Incorrect Jacobian entry: J3a( " << i << ", " << j << " ) = " << tJ3a( i, j ) << " but should be: " << tJ3aNominal( i, j ) << '\n';
                }
            }
        }

        // check the second helper matrix
        bool tJ3bCheck = true;
        for ( uint i = 0; i < 4; i++)
        {
            for ( uint j = 0; j < 3; j++)
            {
                bool tCheckEntry = ( std::abs( tJ3bNominal( i, j ) - tJ3b( i, j ) ) < tEpsilon );
                tJ3bCheck = tJ3bCheck && tCheckEntry;

                // print what entries are wrong
                if( !tCheckEntry )
                {
                    std::cout << "2D: Incorrect Jacobian entry: J3b( " << i << ", " << j << " ) = " << tJ3b( i, j ) << " but should be: " << tJ3bNominal( i, j ) << '\n';
                }
            }
        }
        
        // check the third helper matrix
        bool tJ3cCheck = true;
        for ( uint i = 0; i < 4; i++)
        {
            for ( uint j = 0; j < 2; j++)
            {
                bool tCheckEntry = ( std::abs( tJ3cNominal( i, j ) - tJ3c( i, j ) ) < tEpsilon );
                tJ3cCheck = tJ3cCheck && tCheckEntry;

                // print what entries are wrong
                if( !tCheckEntry )
                {
                    std::cout << "2D: Incorrect Jacobian entry: J3c( " << i << ", " << j << " ) = " << tJ3c( i, j ) << " but should be: " << tJ3cNominal( i, j ) << '\n';
                }
            }
        }

        // break tests at the end, so all errors get printed before interruption
        REQUIRE( tJ3aCheck );
        REQUIRE( tJ3bCheck );
        REQUIRE( tJ3cCheck );

    } // end: SECTION( "Geometry Interpolator : 2D space - 3rd analytic derivatives" )

    //------------------------------------------------------------------------------

    SECTION( "Geometry Interpolator : 3D space - 3rd analytic derivatives" )
    {
        // number of spatial dimensions
        uint tNumDims = 3;

        // create a distorted HEX64 space element
        Matrix< DDRMat > tXHat = {
                { -5.480775719987594e-03, -3.913669721139352e-05, -3.389435648131632e-02 }, 
                { -3.388987399086659e-02, -1.499186842829551e-04, +1.631899559485933e-01 }, 
                { +1.784382814785657e-01, +2.091270356518937e-02, +9.173214198663846e-01 }, 
                { +2.885759330080730e-02, +5.459320505759664e-03, -1.905265494568356e-01 }, 
                { -3.216297474506741e-01, -3.324283118542468e-02, -1.880070907143950e-01 }, 
                { -1.988768044834767e+00, -1.273413923060526e-01, +9.051910712220660e-01 }, 
                { +1.047133879209589e+01, +1.776331483705355e+01, +5.088249174877953e+00 }, 
                { +1.693457444632295e+00, +4.637163656908232e+00, -1.056823199666803e+00 }, 
                { -1.147772757092631e-02, -4.058153892733131e-05, +2.362198316215623e-02 }, 
                { -2.031833151684756e-02, -5.899348610082661e-05, +6.711273335216088e-02 }, 
                { +3.342310808691821e-04, +8.221278628218567e-04, -1.400021716141683e-03 }, 
                { +5.974652279849032e-03, +1.941624852458541e-03, -4.034037161672469e-02 }, 
                { -1.102397062179181e-01, -4.878716963428630e-03, -4.528565577257954e-02 }, 
                { -1.590425122461863e-01, -8.570710242897447e-03, -9.553368614694381e-02 }, 
                { +2.066687234286857e-03, +3.149277693027433e-03, +6.740634899210285e-03 }, 
                { +3.694371440249079e-02, +7.437670115068629e-03, +1.942253563867492e-01 }, 
                { -6.816571126767167e-01, -1.868861912888309e-02, +2.180352406072118e-01 }, 
                { -9.834247877645885e-01, -3.283132442283779e-02, +4.599626501987223e-01 }, 
                { +1.069808686616881e-01, +8.229216344876713e-03, +3.772532904482898e-01 }, 
                { +6.043297722461887e-02, +5.660866741631091e-03, +1.327836079641749e-01 }, 
                { +3.589087518485757e+00, +2.606943582478429e+00, +1.225617075095732e+00 }, 
                { +5.177966407884222e+00, +4.579761079089394e+00, +2.585536523453141e+00 }, 
                { +5.804383850329052e-01, +6.805500069763063e-01, -2.545591841814643e-01 }, 
                { +8.373968157831309e-01, +1.195559602928190e+00, -5.370128088581023e-01 }, 
                { -6.735503893147858e-01, -3.447008419027447e-02, +1.310277223781929e-01 }, 
                { -1.192345786117580e+00, -5.010924884378223e-02, +3.722646203472246e-01 }, 
                { +1.961376703266453e-02, +6.983179395287515e-01, -7.765717869104977e-03 }, 
                { +3.506120304951629e-01, +1.649222131521971e+00, -2.237622038990079e-01 }, 
                { +1.212799295543367e-01, +2.675006174891449e+00, +3.738932638142916e-02 }, 
                { +2.167977333907368e+00, +6.317579910042207e+00, +1.077339946470673e+00 }, 
                { +6.277985366967427e+00, +6.989921716271813e+00, +2.092569411627936e+00 }, 
                { +3.546403683617710e+00, +4.808357650589976e+00, +7.365314589072197e-01 }, 
                { +6.999398420852363e-04, +8.524790349103891e-04, +9.757166926471037e-04 }, 
                { +1.251199368531654e-02, +2.013305417846592e-03, +2.811440245548476e-02 }, 
                { +2.214923067863402e-02, +2.926747194016835e-03, +7.987620609149799e-02 }, 
                { +1.239061448832593e-03, +1.239250935931407e-03, +2.772121788901489e-03 }, 
                { -2.308617210614631e-01, -5.058828579668002e-03, +3.156091778101026e-02 }, 
                { -4.086806342188020e-01, -7.354031941359263e-03, +8.966814703262491e-02 }, 
                { -5.896023946583997e-01, -1.291923211755813e-02, +1.891620750511404e-01 }, 
                { -3.330635517706552e-01, -8.887122218779471e-03, +6.658026172663251e-02 }, 
                { +6.722686357981324e-03, +1.024851210308225e-01, -1.870544482715786e-03 }, 
                { +9.698800587357968e-03, +1.800412450953417e-01, -3.946062091561234e-03 }, 
                { +1.733739450273921e-01, +4.252046083742112e-01, -1.137022443015737e-01 }, 
                { +1.201734837794572e-01, +2.420397933207918e-01, -5.389806364313027e-02 }, 
                { +4.156911451808515e-02, +3.925838304783524e-01, +9.006044174419988e-03 }, 
                { +7.430817151442336e-01, +9.271678487015453e-01, +2.595010953072774e-01 }, 
                { +1.072041887948491e+00, +1.628806720561824e+00, +5.474381627235838e-01 }, 
                { +5.997164389876702e-02, +6.896735929341747e-01, +1.899896518900608e-02 }, 
                { +2.151801156393400e+00, +1.025840713144957e+00, +5.040415108554006e-01 }, 
                { +1.215542104892261e+00, +7.056744326413024e-01, +1.774098518678601e-01 }, 
                { +1.753659155449204e+00, +1.239697062429953e+00, +3.742601673438133e-01 }, 
                { +3.104397439980027e+00, +1.802150764973625e+00, +1.063315583744905e+00 }, 
                { +4.107474674060350e-02, +7.240983186079838e-01, +5.412159302896708e-03 }, 
                { +7.271215631220819e-02, +1.052623562919208e+00, +1.537655842277590e-02 }, 
                { +1.299788904591759e+00, +2.485988083450048e+00, +4.430617566922681e-01 }, 
                { +7.342444892311516e-01, +1.710107824599236e+00, +1.559465221221411e-01 }, 
                { +1.407851123706757e-02, +1.062686487344622e-01, +1.303637975812677e-03 }, 
                { +2.492234258138230e-02, +1.544830042866585e-01, +3.703783346972836e-03 }, 
                { +4.455071339739187e-01, +3.648435407308777e-01, +1.067211993085971e-01 }, 
                { +2.516648333263424e-01, +2.509753759126982e-01, +3.756316047931654e-02 }, 
                { +2.031102832769936e-02, +1.866879761697104e-01, +2.750127807709373e-03 }, 
                { +3.595539312639143e-02, +2.713887846165895e-01, +7.813425019235955e-03 }, 
                { +6.427318816574801e-01, +6.409407012206663e-01, +2.251368426941563e-01 }, 
                { +3.630761429744594e-01, +4.409022374477549e-01, +7.924246922556824e-02 } }; 

        // get parametric nodal points of a HEX64 element
        Matrix< DDRMat > tParamNodalPoints = { 
                { -1.000000000000000e+00, -1.000000000000000e+00, -1.000000000000000e+00 }, 
                { +1.000000000000000e+00, -1.000000000000000e+00, -1.000000000000000e+00 }, 
                { +1.000000000000000e+00, +1.000000000000000e+00, -1.000000000000000e+00 }, 
                { -1.000000000000000e+00, +1.000000000000000e+00, -1.000000000000000e+00 }, 
                { -1.000000000000000e+00, -1.000000000000000e+00, +1.000000000000000e+00 }, 
                { +1.000000000000000e+00, -1.000000000000000e+00, +1.000000000000000e+00 }, 
                { +1.000000000000000e+00, +1.000000000000000e+00, +1.000000000000000e+00 }, 
                { -1.000000000000000e+00, +1.000000000000000e+00, +1.000000000000000e+00 }, 
                { -3.333333333333333e-01, -1.000000000000000e+00, -1.000000000000000e+00 }, 
                { +3.333333333333333e-01, -1.000000000000000e+00, -1.000000000000000e+00 }, 
                { -1.000000000000000e+00, -3.333333333333333e-01, -1.000000000000000e+00 }, 
                { -1.000000000000000e+00, +3.333333333333333e-01, -1.000000000000000e+00 }, 
                { -1.000000000000000e+00, -1.000000000000000e+00, -3.333333333333333e-01 }, 
                { -1.000000000000000e+00, -1.000000000000000e+00, +3.333333333333333e-01 }, 
                { +1.000000000000000e+00, -3.333333333333333e-01, -1.000000000000000e+00 }, 
                { +1.000000000000000e+00, +3.333333333333333e-01, -1.000000000000000e+00 }, 
                { +1.000000000000000e+00, -1.000000000000000e+00, -3.333333333333333e-01 }, 
                { +1.000000000000000e+00, -1.000000000000000e+00, +3.333333333333333e-01 }, 
                { +3.333333333333333e-01, +1.000000000000000e+00, -1.000000000000000e+00 }, 
                { -3.333333333333333e-01, +1.000000000000000e+00, -1.000000000000000e+00 }, 
                { +1.000000000000000e+00, +1.000000000000000e+00, -3.333333333333333e-01 }, 
                { +1.000000000000000e+00, +1.000000000000000e+00, +3.333333333333333e-01 }, 
                { -1.000000000000000e+00, +1.000000000000000e+00, -3.333333333333333e-01 }, 
                { -1.000000000000000e+00, +1.000000000000000e+00, +3.333333333333333e-01 }, 
                { -3.333333333333333e-01, -1.000000000000000e+00, +1.000000000000000e+00 }, 
                { +3.333333333333333e-01, -1.000000000000000e+00, +1.000000000000000e+00 }, 
                { -1.000000000000000e+00, -3.333333333333333e-01, +1.000000000000000e+00 }, 
                { -1.000000000000000e+00, +3.333333333333333e-01, +1.000000000000000e+00 }, 
                { +1.000000000000000e+00, -3.333333333333333e-01, +1.000000000000000e+00 }, 
                { +1.000000000000000e+00, +3.333333333333333e-01, +1.000000000000000e+00 }, 
                { +3.333333333333333e-01, +1.000000000000000e+00, +1.000000000000000e+00 }, 
                { -3.333333333333333e-01, +1.000000000000000e+00, +1.000000000000000e+00 }, 
                { -3.333333333333333e-01, -3.333333333333333e-01, -1.000000000000000e+00 }, 
                { -3.333333333333333e-01, +3.333333333333333e-01, -1.000000000000000e+00 }, 
                { +3.333333333333333e-01, +3.333333333333333e-01, -1.000000000000000e+00 }, 
                { +3.333333333333333e-01, -3.333333333333333e-01, -1.000000000000000e+00 }, 
                { -3.333333333333333e-01, -1.000000000000000e+00, -3.333333333333333e-01 }, 
                { +3.333333333333333e-01, -1.000000000000000e+00, -3.333333333333333e-01 }, 
                { +3.333333333333333e-01, -1.000000000000000e+00, +3.333333333333333e-01 }, 
                { -3.333333333333333e-01, -1.000000000000000e+00, +3.333333333333333e-01 }, 
                { -1.000000000000000e+00, -3.333333333333333e-01, -3.333333333333333e-01 }, 
                { -1.000000000000000e+00, -3.333333333333333e-01, +3.333333333333333e-01 }, 
                { -1.000000000000000e+00, +3.333333333333333e-01, +3.333333333333333e-01 }, 
                { -1.000000000000000e+00, +3.333333333333333e-01, -3.333333333333333e-01 }, 
                { +1.000000000000000e+00, -3.333333333333333e-01, -3.333333333333333e-01 }, 
                { +1.000000000000000e+00, +3.333333333333333e-01, -3.333333333333333e-01 }, 
                { +1.000000000000000e+00, +3.333333333333333e-01, +3.333333333333333e-01 }, 
                { +1.000000000000000e+00, -3.333333333333333e-01, +3.333333333333333e-01 }, 
                { +3.333333333333333e-01, +1.000000000000000e+00, -3.333333333333333e-01 }, 
                { -3.333333333333333e-01, +1.000000000000000e+00, -3.333333333333333e-01 }, 
                { -3.333333333333333e-01, +1.000000000000000e+00, +3.333333333333333e-01 }, 
                { +3.333333333333333e-01, +1.000000000000000e+00, +3.333333333333333e-01 }, 
                { -3.333333333333333e-01, -3.333333333333333e-01, +1.000000000000000e+00 }, 
                { +3.333333333333333e-01, -3.333333333333333e-01, +1.000000000000000e+00 }, 
                { +3.333333333333333e-01, +3.333333333333333e-01, +1.000000000000000e+00 }, 
                { -3.333333333333333e-01, +3.333333333333333e-01, +1.000000000000000e+00 }, 
                { -3.333333333333333e-01, -3.333333333333333e-01, -3.333333333333333e-01 }, 
                { +3.333333333333333e-01, -3.333333333333333e-01, -3.333333333333333e-01 }, 
                { +3.333333333333333e-01, +3.333333333333333e-01, -3.333333333333333e-01 }, 
                { -3.333333333333333e-01, +3.333333333333333e-01, -3.333333333333333e-01 }, 
                { -3.333333333333333e-01, -3.333333333333333e-01, +3.333333333333333e-01 }, 
                { +3.333333333333333e-01, -3.333333333333333e-01, +3.333333333333333e-01 }, 
                { +3.333333333333333e-01, +3.333333333333333e-01, +3.333333333333333e-01 }, 
                { -3.333333333333333e-01, +3.333333333333333e-01, +3.333333333333333e-01 } };

        // create a space and time geometry interpolation rule
        mtk::Interpolation_Rule tGeomInterpRule( mtk::Geometry_Type::HEX,
                mtk::Interpolation_Type::LAGRANGE,
                mtk::Interpolation_Order::CUBIC,
                mtk::Interpolation_Type::CONSTANT,
                mtk::Interpolation_Order::CONSTANT );

        // create a space and time geometry interpolator
        Geometry_Interpolator tGeomInterpolator( tGeomInterpRule );

        //set nodal points xHat, tHat
        tGeomInterpolator.set_space_coeff( tXHat );

        // test that the nodal points used to generate the unit test are indeed the nodal points in the order used by moris
        for( uint iNode = 0; iNode < tXHat.n_rows(); iNode++ )
        {
            // set space interpolator to each parametric nodal point
            Matrix< DDRMat > tXi = tParamNodalPoints( { iNode, iNode }, { 0, tNumDims - 1 } );
            tGeomInterpolator.set_space( trans( tXi ) );

            // check that the space interpolation puts it on top of the physical nodal points provided
            Matrix< DDRMat > tXNodeNominal = tXHat( { iNode, iNode }, { 0, tNumDims - 1 } ); 
            Matrix< DDRMat > tXNode = tGeomInterpolator.valx();
            if( norm( tXNode - tXNodeNominal ) > tEpsilon )
            {
                std::cout << "Incorrect spatial position of nodal point #" << iNode << '\n';
                moris::print_as_row_vector( tXNodeNominal, "tXNodeNominal" );
                moris::print_as_row_vector( tXNode, "tXNode" );
            }
            REQUIRE( norm( tXNode - tXNodeNominal ) < tEpsilon );
        }

        // set random test point in parent element
        Matrix< DDRMat > tXi = {
                { -2.528723847147101e-01 }, 
                { -8.249993008468286e-01 }, 
                { +2.802330964934301e-01 } };  
        tGeomInterpolator.set_space( tXi );

        // the known physical position of this point
        Matrix< DDRMat > tXNominal = { 
                { -1.866263321954227e-01 }, 
                { +5.857489018537319e-02 }, 
                { +4.585824761324228e-02 } };
        tXNominal = trans( tXNominal );      

        // get the interpolated physical point position
        Matrix< DDRMat > tX = tGeomInterpolator.valx();

        // check that the interpolated physical point position is correct
        if( norm( tX - tXNominal ) > tEpsilon )
        {
            std::cout << "Incorrect spatial point: " << '\n';
            moris::print_as_row_vector( tXNominal, "tXNominal" );
            moris::print_as_row_vector( tX, "tX" );
        }
        REQUIRE( norm( tX - tXNominal ) < tEpsilon );

        // first help matrix
        Matrix< DDRMat > tJ3aNominal = {
                { -4.829899088460756e-03, +3.041490803625456e-07, +8.005526153135467e-04, +5.764683419040359e-04, +7.959331375792840e-03, -2.293462334865568e-05, +1.259821125780645e-05, -4.372137994976186e-03, +1.739442235664311e-04, -6.333193132792509e-04 }, 
                { +3.843241059605581e-01, +3.262197812543135e-02, -3.413110256651097e-03, +5.067064537908336e-01, -2.387645122475384e-01, +2.226865522539213e-01, -4.611528412987458e-02, +4.944480576389303e-02, +2.172992516683303e-02, -2.098637016963739e-01 }, 
                { -1.992968675659596e-03, +1.005492440052880e-03, +1.368589188963353e-04, +4.759717455952817e-03, +2.448382527500279e-03, -3.789139711893038e-03, +1.551665709913201e-03, -1.002621043702503e-03, +7.981715822062984e-04, -3.898241250960642e-03 }, 
                { +2.077421298788559e-02, +1.445088469677926e-05, -1.298105608787832e-03, +7.476826421490014e-03, -2.712500398141508e-02, -6.935723725944843e-04, +3.922390002113014e-04, +1.099475094873044e-02, +2.566806841725892e-03, -8.779879572182962e-03 }, 
                { -3.595772408780494e-03, +4.530894413573255e-06, +4.443081593489547e-04, +3.148654003348287e-03, +5.422866520745261e-03, -2.334621342043292e-04, +1.274473134814843e-04, -2.702688887435963e-03, +9.281058546008244e-04, -3.419171960503643e-03 }, 
                { -8.935340415229487e-02, +6.865977311872387e-04, +2.104893718830019e-03, -7.498288705603985e-02, +8.609038391805793e-02, -1.413322837775551e-02, +8.832832443344043e-03, -2.416057305176091e-02, -8.781567488474241e-03, +5.793331001209091e-02 }, 
                { -6.652199132877284e-02, +1.022821381179301e-02, +1.168219847076823e-03, -5.512799390562283e-03, +5.479253985138458e-02, +3.369891543128298e-02, -4.377889071776625e-03, -1.413522860110525e-02, -2.687347410208679e-03, +1.411858251400603e-02 }, 
                { -2.676987444031178e-03, +6.749651901784071e-05, +2.465918375480393e-04, +4.368722302568434e-03, +3.662966273969904e-03, -1.866115516767190e-03, +1.001368260722679e-03, -1.653257864913653e-03, +9.766213577992399e-04, -4.173898531821017e-03 }, 
                { +1.151417582637783e-02, +3.206928696276598e-03, -3.998516041035425e-04, -1.327229371170134e-02, -1.181461447827835e-02, -7.596250015658541e-04, +1.788133657863078e-03, +3.883708199712143e-03, -7.060774755574858e-04, +7.159278278943191e-03 }, 
                { +1.546602537813567e-02, +2.152741434094809e-04, -7.204509767982971e-04, -6.130597801565673e-03, -1.803182682808832e-02, -5.191553343395800e-03, +2.981599644428403e-03, +6.549878134978710e-03, +7.618748906135079e-05, +3.175306342026959e-03 } }; 

        // second help matrix
        Matrix< DDRMat > tJ3bNominal = {
                { +5.293031925027891e-02, +1.542564084840606e-03, -6.080712274968570e-03, +2.085786446366287e-02, -1.800540436022492e-02, -4.087860828521257e-02 }, 
                { -4.027213200456974e+00, -5.915120283990940e-01, -9.481221317410264e-02, +4.799362806185978e-01, +1.291819411309511e+00, -3.115814305162099e+00 }, 
                { +1.037364148378188e-01, +9.759768455600509e-02, +7.434280706088175e-03, +6.465634756403676e-02, -6.063479728639562e-02, -2.051800684557575e-01 }, 
                { -2.985163774220537e-01, +2.492377693875141e-02, -5.332718484626830e-02, -1.577446857710110e-02, +2.252001396523525e-01, +1.869364417377326e-02 }, 
                { +5.166968077824525e-02, +7.814538975741969e-03, +1.825252366364248e-02, +5.292747494981261e-03, -5.907521667469871e-02, -2.550025286480582e-02 }, 
                { +1.269667020063335e+00, +1.929354595777321e-02, +1.112905023538451e-01, -2.617507196099949e-01, -8.485148709960705e-01, +5.660640499553954e-01 }, 
                { +9.452441045796777e-01, +2.874150383551790e-01, +6.176643147245327e-02, -2.834583891613945e-01, -5.152239751262164e-01, +1.000640168807587e+00 }, 
                { +7.513501181453321e-02, +4.488463027786261e-03, +1.521954390870790e-02, +5.256834977448584e-02, -7.165237430571940e-02, -8.247251647764280e-02 }, 
                { -3.231683953835666e-01, +2.132581219807739e-01, -2.467867187386366e-02, -1.110301971427266e-02, +1.694469494862298e-01, +1.089854027312102e-01 }, 
                { -2.486148422282769e-01, +1.102558499357992e-02, -4.713117144430017e-02, +5.256372081131645e-02, +2.394487422411434e-01, -5.578145215589688e-02 } }; 

        // third help matrix
        Matrix< DDRMat > tJ3cNominal = {
                { -9.620378661332465e-02, +2.691250629256915e-01, +3.643659911698893e-01 }, 
                { +3.704966922577106e+00, +1.500604672250391e+00, +2.979259122285743e-01 }, 
                { -6.977599266239884e-01, +5.608580081742954e-01, +5.791190778176246e-03 }, 
                { +4.066276070126408e-01, +4.170790790961185e-01, +7.166975010090756e-02 }, 
                { -7.038246554982050e-02, +1.307699361767143e-01, -2.453071193342207e-02 }, 
                { -1.672337480603256e+00, -7.084723647576509e-02, +4.250161460337134e-01 }, 
                { -1.245024970664360e+00, -1.055407918980106e+00, +2.358847350262729e-01 }, 
                { -2.488759440452152e-01, +3.728287052337678e-02, +9.736566569747303e-02 }, 
                { +1.070457534301010e+00, +1.771402571581192e+00, -1.578795875843191e-01 }, 
                { +4.440510248538489e-01, +6.274352348299769e-02, -3.425859316285076e-01 } }; 

        // get the derivatives of the shape functions
        Matrix< DDRMat > tdNdXi   = tGeomInterpolator.dNdXi();
        Matrix< DDRMat > td2NdXi2 = tGeomInterpolator.d2NdXi2();
        Matrix< DDRMat > td3NdXi3 = tGeomInterpolator.d3NdXi3();

        // get the first and second order Jacobians
        Matrix< DDRMat > tJ = tGeomInterpolator.space_jacobian();
        Matrix< DDRMat > tJ2b;
        tGeomInterpolator.second_space_jacobian( tJ2b );

        // get the third order Jacobians
        Matrix< DDRMat > tJ3a;
        Matrix< DDRMat > tJ3b;
        Matrix< DDRMat > tJ3c;
        tGeomInterpolator.space_jacobian_and_matrices_for_third_derivatives( tJ, tJ2b, tJ3a, tJ3b, tJ3c, tdNdXi, td2NdXi2, td3NdXi3 );

        // check the first helper matrix
        bool tJ3aCheck = true;
        for ( uint i = 0; i < 10; i++)
        {
            for ( uint j = 0; j < 10; j++)
            {
                bool tCheckEntry = ( std::abs( tJ3aNominal( i, j ) - tJ3a( i, j ) ) < tEpsilon );
                tJ3aCheck = tJ3aCheck && tCheckEntry;

                // print what entries are wrong
                if( !tCheckEntry )
                {
                    std::cout << "3D: Incorrect Jacobian entry: J3a( " << i << ", " << j << " ) = " << tJ3a( i, j ) << " but should be: " << tJ3aNominal( i, j ) << '\n';
                }
            }
        }

        // check the second helper matrix
        bool tJ3bCheck = true;
        for ( uint i = 0; i < 10; i++)
        {
            for ( uint j = 0; j < 6; j++)
            {
                bool tCheckEntry = ( std::abs( tJ3bNominal( i, j ) - tJ3b( i, j ) ) < tEpsilon );
                tJ3bCheck = tJ3bCheck && tCheckEntry;

                // print what entries are wrong
                if( !tCheckEntry )
                {
                    std::cout << "3D: Incorrect Jacobian entry: J3b( " << i << ", " << j << " ) = " << tJ3b( i, j ) << " but should be: " << tJ3bNominal( i, j ) << '\n';
                }
            }
        }
        
        // check the third helper matrix
        bool tJ3cCheck = true;
        for ( uint i = 0; i < 10; i++)
        {
            for ( uint j = 0; j < 3; j++)
            {
                bool tCheckEntry = ( std::abs( tJ3cNominal( i, j ) - tJ3c( i, j ) ) < tEpsilon );
                tJ3cCheck = tJ3cCheck && tCheckEntry;

                // print what entries are wrong
                if( !tCheckEntry )
                {
                    std::cout << "3D: Incorrect Jacobian entry: J3c( " << i << ", " << j << " ) = " << tJ3c( i, j ) << " but should be: " << tJ3cNominal( i, j ) << '\n';
                }
            }
        }

        // break tests at the end, so all errors get printed before interruption
        REQUIRE( tJ3aCheck );
        REQUIRE( tJ3bCheck );
        REQUIRE( tJ3cCheck );

    } // end: SECTION( "Geometry Interpolator : 3D space - 3rd analytic derivatives" )

    //------------------------------------------------------------------------------
}

//------------------------------------------------------------------------------
